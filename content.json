{"meta":{"title":"방종하다","subtitle":null,"description":null,"author":"呢他Yang","url":"https://er-yang.github.io"},"pages":[],"posts":[{"title":"JavaScript闭包与settimeout","slug":"JavaScript","date":"2017-08-24T03:33:27.000Z","updated":"2017-11-05T11:49:51.434Z","comments":true,"path":"2017/08/24/JavaScript/","link":"","permalink":"https://er-yang.github.io/2017/08/24/JavaScript/","excerpt":"闭包settimeout","text":"闭包settimeout 闭包是指有权访问另一个函数作用域中的变量的函数 settimeout settimeout设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码 functionfunction 是你想要在delay毫秒之后执行的函数。code这是一个替代语法，你可以使用字符串代替function ，在delay毫秒之后执行字符串 (使用该语法是不推荐的, 原因和使用 eval()一样，有安全风险)。delay 可选延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0。实际的延迟时间可能会比 delay 值长，原因请查看Reasons for delays longer than specified。param1, …, paramN 可选附加参数，一旦定时器到期，它们会作为参数传递给function 或 执行字符串（setTimeout参数中的code）","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://er-yang.github.io/tags/HTML/"}]},{"title":"HtmlElement","slug":"HtmlElement","date":"2017-08-24T03:33:27.000Z","updated":"2017-08-24T04:51:06.160Z","comments":true,"path":"2017/08/24/HtmlElement/","link":"","permalink":"https://er-yang.github.io/2017/08/24/HtmlElement/","excerpt":"行内元素vs块级元素Inline elementsBlock-level elements","text":"行内元素vs块级元素Inline elementsBlock-level elements 行内元素vs块级元素内容 一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。 格式 默认情况下，行内元素不会以新行开始，而块级元素会新起一行。 The following elements are inline by default:more The following is a complete list of all HTML block level elements (although “block-level” is not technically defined for elements that are new in HTML5).more 区别 块级元素只能出现在 元素内 HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的内容类别代替。”块级“类别大致相当于 HTML5 中的流内容类别，而”行内“类别相当于 HTML5 中的措辞内容类别，不过除了这两个还有其他类别。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://er-yang.github.io/tags/HTML/"}]},{"title":"页面渲染","slug":"webBrowser","date":"2017-08-07T16:00:00.000Z","updated":"2017-08-28T08:25:47.818Z","comments":true,"path":"2017/08/08/webBrowser/","link":"","permalink":"https://er-yang.github.io/2017/08/08/webBrowser/","excerpt":"浏览器渲染页面构建对象模型 文档对象模型DOM css对象模型CSSOM","text":"浏览器渲染页面构建对象模型 文档对象模型DOM css对象模型CSSOM DOM构建 转换： 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符 令牌化： 浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“”、“”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则 词法分析： 发出的令牌转换成定义其属性和规则的“对象”. DOM 构建： 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推. CSSOM 与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML，CSS 是阻塞渲染的资源&gt; 过程 DOM 树与 CSSOM 树合并后形成渲染树。 渲染树只包含渲染网页所需的节点。 布局计算每个对象的精确位置和大小。 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上 第一步是让浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。 回溯 当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流. 重绘 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color. 引起回溯重绘的操作 添加、删除元素(回流+重绘) 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 移动元素，比如改变top,left,transform的值，或者移动元素到另外一个父元素中。(重绘+回流) 对style的操作(对不同的属性操作，影响不一样) 还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘) 页面渲染机制来自 页面渲染就是浏览器的渲染引擎将html代码根据CSS定义的规则显示在浏览器窗口中的过程。大致工作原理如下： 用户输入网址，浏览器向服务器发出请求，服务器返回html文件； 渲染引擎开始载入html代码，并将HTML中的标签转化为DOM节点，生成DOM树； 如果中引用了外部css文件，则发出css文件请求，服务器返回该文件； 如果中引用了外部js文件，则发出js文件请求，服务器返回该文件后开始运行； 渲染引擎继续载入html中的部分的代码，并开始解析前面返回的css文件，然后根据css选择器计算出节点的样式，创建渲染树； 从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标； 如果body中的引用了图片资源，则立即向服务器发出请求，此时渲染引擎不会等待图片下载完毕，而是继续渲染后面的代码； 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排版，因此引擎需要回过头来重新渲染这部分代码； 如果此时js脚本中运行了style.display=”none”, 布局被改变，引擎也需要重新渲染这部分代码； 直到为止，页面渲染完毕 注意 1.chrome 不管HTML css在前面还是在后面都要等 css下载完再展示 2.Ie只要看见一个HTML 就展示 3.Firefox 如果link在head里面就等css下载完再展示；如果link在body里面，则遇见一个HTML标签就展示。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://er-yang.github.io/tags/学习/"}]},{"title":"JavaScript&ReactJs&css","slug":"tag","date":"2017-08-04T07:11:43.000Z","updated":"2017-08-08T12:23:31.167Z","comments":true,"path":"2017/08/04/tag/","link":"","permalink":"https://er-yang.github.io/2017/08/04/tag/","excerpt":"React学习 4.0版本中没有集中式的routes配置 取消掉了IndexRoute，用switch替代 React Fiber","text":"React学习 4.0版本中没有集中式的routes配置 取消掉了IndexRoute，用switch替代 React Fiber css3filter滤镜 对元素直接使用模糊会将其内容全部模糊掉 伪元素 伪类 伪元素不属于文档，所以js无法操作它 position 定位 relative：如果对一个元素进行相对定位，首先它将出现在它所在的位置上。然后通过设置垂直或水平位置，让这个元素”相对于”它的原始起点进行移动。（再一点，相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框）。 absolute; 表示绝对定位，位置将依据浏览器左上角开始计算。 绝对定位使元素脱离文档流，因此不占据空间。普通文档流中元素的布局就像绝对定位的元素不存在时一样。（因为绝对定位的框与文档流无关，所以它们可以覆盖页面上的其他元素并可以通过z-index来控制它层级次序。z-index的值越高，它显示的越在上层。）。 父容器使用相对定位，子元素使用绝对定位后，这样子元素的位置不再相对于浏览器左上角，而是相对于父窗口左上角 jsa标签中先执行点击事件，在点击事件返回true的前提下在执行href跳转 脚本在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://er-yang.github.io/tags/笔记/"}]},{"title":"","slug":"prototype","date":"2017-05-12T02:58:39.276Z","updated":"2017-05-12T03:00:53.086Z","comments":true,"path":"2017/05/12/prototype/","link":"","permalink":"https://er-yang.github.io/2017/05/12/prototype/","excerpt":"","text":"原型模式 组合构造函数模式和原型模式 动态原型模式 寄生构造函数模式","categories":[],"tags":[]},{"title":"","slug":"first","date":"2017-03-06T13:14:38.387Z","updated":"2017-08-04T07:22:35.231Z","comments":true,"path":"2017/03/06/first/","link":"","permalink":"https://er-yang.github.io/2017/03/06/first/","excerpt":"","text":"webpack-Dev-server配置详解123456789module: &#123; rules: [ &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&apos;style!css&apos;) &#125;, //坑：不能用叹号链接，必须写成这种格式 &#123; test: /\\.less$/, loader: ExtractTextPlugin.extract(&apos;css!less&apos;) &#125;, &#123; test: /\\.js[x]?$/, exclude: /node_modules/, use: &apos;babel-loader&apos; &#125;, &#123; test: /\\.(png|jpg)$/, loader: &apos;url?limit=8192&amp;name=img/[name].[ext]&apos; &#125; //&#123; test: /\\.(woff|woff2|eot|ttf|svg)(\\?.*$|$)/, use: &apos;url&apos; &#125;//url loader相当于一个文件加载器返回一个dataURL ] &#125;, 配置热替换1234567891011121314151617 &quot;presets&quot;: [ [&quot;es2015&quot;, &#123;&quot;modules&quot;: false&#125;], // webpack现在已经支持原生的import语句了, 并且将其运用在tree-shaking特性上 &quot;stage-2&quot;, // 规定JS运用的语言规范层级 // Stage 2 是 &quot;草案&quot;, 4 是 &quot;已完成&quot;, 0 is &quot;稻草人(strawman)&quot;。 // 详情查看 https://tc39.github.io/process-document/ &quot;react&quot; // 转译React组件为JS代码 ], &quot;plugins&quot;: [ &quot;react-hot-loader/babel&quot; // 开启react代码的模块热替换（HMR） ]&#125;","categories":[],"tags":[]}]}